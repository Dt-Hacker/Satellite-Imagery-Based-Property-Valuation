ğŸ  Multimodal Real Estate Price Prediction

Tabular Data + Satellite Imagery

ğŸ“Œ Project Overview

This project implements a multimodal regression pipeline to predict real estate prices by combining structured housing attributes with satellite imagery capturing neighborhood-level spatial context. The primary objective is to evaluate whether visual information extracted from satellite images can enhance predictive performance beyond traditional tabular models.

All experiments, training, and evaluation were performed using Kaggle Notebooks.

ğŸ“‚ Repository Contents
.
â”œâ”€â”€ multimodal_real_estate.ipynb   # Single notebook containing the complete pipeline
â”œâ”€â”€ train.xlsx                     # Training dataset
â”œâ”€â”€ test.xlsx                      # Test dataset
â”œâ”€â”€ prediction.csv                 # Final predictions generated by the model
â””â”€â”€ README.md


Note: All code (preprocessing, modeling, CNN extraction, explainability) is contained within a single notebook.

ğŸ“Š Dataset Description
Input Data

train.xlsx
Contains housing features along with the target variable price.

test.xlsx
Contains the same housing features but without the target variable.

Target Variable

price â€“ the market value of the property.

Key Features

Structural attributes:

bedrooms, bathrooms

sqft_living, sqft_lot

grade, condition

view, waterfront

Neighborhood context:

sqft_living15, sqft_lot15

Spatial coordinates:

lat, long

ğŸ§¹ Data Preprocessing

Rows with missing target values (price) are removed.

Missing numerical values are handled using median imputation.

The target variable is log-transformed to reduce skewness and stabilize variance:

log_price = log(price + 1)


This transformation improves regression stability and reduces the influence of extreme price outliers.

ğŸŒ Satellite Image Acquisition

Satellite images are programmatically fetched using the ESRI World Imagery service via the ArcGIS REST API.

API Endpoint
https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/export

How Images Are Retrieved

Latitude and longitude values are used to compute a geographic bounding box around each property.

A fixed spatial area surrounding the property is requested.

Images are retrieved using standard HTTP GET requests.

Each property is associated with one satellite image capturing its surrounding environment.

These images provide visual information about neighborhood layout, surrounding house density, greenery, and open spaces.

ğŸ§  CNN Feature Extraction

A pretrained Convolutional Neural Network (CNN) is used to convert satellite images into numerical representations.

CNN Architecture

Model: ResNet-18

Pretraining: ImageNet

Framework: PyTorch

How the CNN Is Used

The final classification layer is removed.

The CNN is used only as a feature extractor.

Each satellite image is converted into a 512-dimensional embedding.

No CNN fine-tuning is performed.

Image Preprocessing

Images are resized to 224 Ã— 224

Normalized using ImageNet mean and standard deviation

These embeddings encode high-level visual characteristics of the neighborhood, which are later used by regression models.

ğŸ“ˆ Baseline Model (Tabular Only)
Model Used

XGBoost Regressor

Rationale

XGBoost is well-suited for structured data due to its ability to model non-linear feature interactions and handle heterogeneous feature scales.

Performance

RÂ² (log scale): 0.6993

RMSE (price scale): 187,610.99

This model serves as the baseline reference.

ğŸ”¬ Tried Architectures
Random Forest (Multimodal)

A Random Forest regressor was evaluated using tabular features combined with CNN embeddings.

RÂ² (log scale): 0.7273

Reason for Lower Performance

Random Forest builds trees independently (bagging).

Less effective at handling high-dimensional and noisy CNN embeddings.

Lacks gradient-based error correction.

ğŸ† Final Model: Multimodal XGBoost
Architecture
Tabular Features â”€â”
                  â”œâ”€â”€ XGBoost â”€â”€â–º Price Prediction
CNN Embeddings â”€â”€â”€â”˜


CNN embeddings are concatenated with tabular features.

XGBoost learns joint interactions across both modalities.

Performance

Multimodal RÂ² (log scale): 0.7663

Multimodal RMSE (price scale): 169,231.18

This demonstrates a clear improvement over the tabular-only baseline, indicating that satellite imagery contributes useful neighborhood context.

ğŸ” Exploratory Data Analysis (EDA)

Correlation heatmaps show that price is most strongly influenced by grade and sqft_living.

Spatial plots reveal geographic clustering of property prices.

Visual inspection of satellite images highlights the role of:

surrounding house density

neighborhood layout

open spaces

ğŸ§  Explainability with Grad-CAM

Grad-CAM (Gradient-weighted Class Activation Mapping) is used to visualize which regions of the satellite images influence CNN feature extraction.

Observations

CNN attention focuses on:

open spaces

greenery

surrounding house density

Less emphasis on individual buildings

Interpretation

This confirms that satellite imagery contributes neighborhood-level environmental context, complementing structured housing attributes rather than replacing them.

â–¶ï¸ How to Run (Kaggle)

Open a new Kaggle Notebook

Upload the following files:

train.xlsx

test.xlsx

multimodal_real_estate.ipynb

Run all cells in order

The notebook will generate:

prediction.csv

No additional setup is required on Kaggle.

â–¶ï¸ How to Run (Local Machine)
Requirements

Install the required packages:

pip install numpy pandas scikit-learn xgboost torch torchvision pillow tqdm matplotlib seaborn requests

Steps

Place the following files in the same directory:

multimodal_real_estate.ipynb

train.xlsx

test.xlsx

Open the notebook using Jupyter or VS Code

Run all cells sequentially

prediction.csv will be generated in the working directory

ğŸ“¤ Output

prediction.csv

id,predicted_price

ğŸ“Œ Final Takeaway

Structural housing attributes dominate real estate price prediction, while satellite imagery provides complementary neighborhood-level context that improves performance when fused using XGBoost